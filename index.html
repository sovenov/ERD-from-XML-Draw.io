<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>draw.io ERD → текст и таблицы (Confluence)</title>
<style>
  :root{ --bg:#f1f3f4; --ink:#1f2328; --muted:#5f6b76; --panel:#ffffff; --border:#d6d9de; --accent:#2563eb; }
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial}
  .wrap{max-width:1200px;margin:24px auto;padding:0 16px}
  h2{font-size:16px;margin:18px 0 8px}
  .row{display:grid;grid-template-columns:1fr;gap:12px;margin-bottom:18px}
  .field{position:relative}
  .label{font-weight:600;color:var(--muted);margin-bottom:6px}
  textarea,pre{width:100%;min-height:220px;resize:vertical;padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:var(--panel);color:var(--ink);font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  pre{white-space:pre-wrap;word-break:break-word}
  .top-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:-6px;margin-bottom:6px}
  button{background:var(--accent);border:0;color:#fff;padding:6px 10px;border-radius:8px;cursor:pointer;font-weight:600;transition:all 0.2s}
  .copy-btn,.btn,.copy-btn-inline,.file-btn{background:#e5eaf3;color:#111;border:1px solid var(--border)}
  .copy-btn:hover,.copy-btn-inline:hover,.btn:hover,.file-btn:hover{filter:brightness(0.96)}
  .btn-active{background:#cbd3e6 !important; box-shadow:0 0 6px rgba(0,0,0,0.25) inset;}
  .file-btn {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    margin-right: 10px;
    margin-bottom: 8px;
    font-size: 14px;
    line-height: 1.1;
    text-align: left;
    position: relative;
    vertical-align: middle;
    transition: box-shadow .2s;
    user-select: none;
  }
  .file-btn svg {
    width: 1em; height: 1em; display: inline-block; vertical-align: middle;
    margin-right: 2px;
  }
  #xmlUploadInput {display:none;}
  .hint{color:var(--muted);font-size:12px;margin-top:6px}
  .error{color:#b00020}
  .tables-wrap{display:flex;flex-direction:column;gap:16px}
  .table-card{background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:8px 8px 12px;position:relative}
  .table-title{font-weight:700;margin:2px 0 8px 0}
  .copy-btn-inline{position:absolute;right:8px;top:8px}
  table{width:100%;border-collapse:collapse;font:13px/1.4 ui-sans-serif,system-ui,Segoe UI,Roboto,Ubuntu,Arial}
  th,td{border:1px solid var(--border);padding:6px 8px;text-align:left;background:#fff}
  th{background:#eef2f8}
  .camel-note{margin-top:8px;font-size:12px;color:#8a3d00;background:#fff7ed;border:1px solid #ffd7a3;border-radius:6px;padding:8px}
  .note-title{font-weight:700;margin-bottom:4px}
  .warn-note{margin-top:8px;font-size:12px;color:#7a4b00;background:#fff7cc;border:1px solid #ffd666;border-radius:6px;padding:8px}
  .warn-title{font-weight:700;margin-bottom:4px}
  .toast { position: fixed; right: 16px; bottom: 16px; background:#111; color:#fff; padding:10px 12px; border-radius:10px;
           box-shadow:0 4px 20px rgba(0,0,0,0.25); opacity:0; transform: translateY(8px);
           transition: opacity .25s ease, transform .25s ease; pointer-events:none; z-index:9999; font-size:13px; }
  .toast.show { opacity:1; transform: translateY(0); }
  .toast.hide { opacity:0; transform: translateY(8px); }
  #xmlInput.dropzone {
    border: 2px dashed var(--accent);
    background: #e6eeff;
  }
  .checkbox-container {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
    font-size: 13px;
  }
  .checkbox-container input {
    margin: 0;
  }
</style>
</head>
<body>
<div class="wrap">
  <h2>ERD из draw.io → текст и таблицы (Confluence)</h2>

  <div class="row">
    <div class="field">
      <div class="label">1. XML Drawio</div>
      <div class="top-actions">
        <button onclick="run()">Преобразовать</button>
      </div>
      <label class="file-btn" id="xmlUploadLabel" for="xmlUploadInput" tabindex="0">
        <svg viewBox="0 0 20 20" fill="none"><path d="M7.5 9.5L13 4M13 4C13.8284 3.17157 15.1716 3.17157 16 4C16.8284 4.82843 16.8284 6.17157 16 7L8.46447 14.5355C6.92893 16.0711 4.57107 16.0711 3.03553 14.5355C1.5 13 1.5 10.6421 3.03553 9.10656L10 2.14214" stroke="#111" stroke-width="1.5" stroke-linecap="round"/></svg>
        Загрузить XML/DRAWIO/TXT
      </label>
      <input type="file" id="xmlUploadInput" accept=".xml,.drawio,.txt,text/xml,text/plain,application/xml" />
      <textarea id="xmlInput" placeholder="Вставьте несжатый XML из diagrams.net (File → Export as → XML) или перетащите файл"></textarea>
      <div class="checkbox-container">
        <input type="checkbox" id="colorCheckbox">
        <label for="colorCheckbox">Учитывать цвета</label>
      </div>
      <div class="hint">Можно вставить текст, перетащить xml/drawio/txt файл или выбрать его кнопкой выше. Поддерживаются shape=table и строки как shape=tableRow/partialRectangle; флаги PK, FK, UN1..; связи — рёбра между строками; кардинальности — edgeLabel (1:1/1:n/n:n) и/или стрелочные ERD-стили.</div>
    </div>
  </div>
  <div class="row">
    <div class="field">
      <div class="label">2. Схема в текстовом варианте</div>
      <div class="top-actions" style="position:absolute; right:8px; top:-2px;">
        <button class="btn" onclick="analyzeDB(this)">Анализ БД через промпт ИИ</button>
        <button class="btn" onclick="copyPromptPlusOutput(this)">Создать БД через промпт ИИ</button>
        <button class="btn" onclick="copyFrom('output', this)">Копировать</button>
      </div>
      <pre id="output" aria-live="polite" style="padding-top:40px;"></pre>
    </div>
  </div>
  <div class="row">
    <div class="field">
      <div class="label">3. Таблицы (для вставки в Confluence)</div>
      <div id="tablesContainer" class="tables-wrap"></div>
      <div class="hint">«Копировать» у каждой таблицы кладёт в буфер <b>HTML</b> (и plain-текст как запасной) — Confluence вставит именно таблицу. Предупреждения по правилам показываются ниже каждой таблицы.</div>
    </div>
  </div>
</div>
<div id="toast" class="toast" role="status" aria-live="polite">Скопировано в буфер.</div>
<script>
// --- drag & drop и file select ---
const xmlInput = document.getElementById('xmlInput');
const xmlUploadInput = document.getElementById('xmlUploadInput');
const colorCheckbox = document.getElementById('colorCheckbox');
['dragenter', 'dragover'].forEach(ev => {
  xmlInput.addEventListener(ev, e => {
    e.preventDefault(); e.stopPropagation();
    xmlInput.classList.add('dropzone');
  });
});
['dragleave', 'drop'].forEach(ev => {
  xmlInput.addEventListener(ev, e => {
    e.preventDefault(); e.stopPropagation();
    xmlInput.classList.remove('dropzone');
  });
});
xmlInput.addEventListener('drop', function(e) {
  e.preventDefault(); e.stopPropagation();
  xmlInput.classList.remove('dropzone');
  const files = e.dataTransfer.files;
  if (files && files.length > 0) {
    const file = files[0];
    if (!/\.xml$|\.drawio$|\.txt$/i.test(file.name)) {
      showToast('Можно только XML, DRAWIO или TXT');
      return;
    }
    const reader = new FileReader();
    reader.onload = function(evt) {
      xmlInput.value = evt.target.result;
      showToast('Файл загружен');
    };
    reader.readAsText(file, 'utf-8');
  }
});
xmlUploadInput.addEventListener('change', function(e) {
  const files = e.target.files;
  if (files && files.length > 0) {
    const file = files[0];
    if (!/\.xml$|\.drawio$|\.txt$/i.test(file.name)) {
      showToast('Можно только XML, DRAWIO или TXT');
      xmlUploadInput.value = '';
      return;
    }
    const reader = new FileReader();
    reader.onload = function(evt) {
      xmlInput.value = evt.target.result;
      showToast('Файл загружен');
    };
    reader.readAsText(file, 'utf-8');
  }
});
var prompt_ai_sql = `1. Напиши SQL запрос для создания таблиц в базе данных postgresql 14, с данными из схемы ниже "Схема таблиц базы данных", но только без всех связей, индексов и ограничений!
Для PK id используй serial, для PK uuid используй uuid.
Новую базу данных создавать не нужно, скрипт будет выполняться внутри уже существующей базы данных.
Для создания таблиц используй проверку на существования такой таблицы "create table if not exists". 
Названия всех столбцов оберни в кавычки для избежания конфликтов с ключевыми словами postgresql 14.
Никогда не используй тип данных "TEXT". Вместо этого лучше используй "varchar". Если посчитаешь необходимым использовать тип данных varchar, тогда varchar должен быть без ограничений, если я явно не укажу тебе обратное для определённых столбцов в моих предпочтениях.
Проверь внимательно, чтобы он точно работал для postgresql 14!

2. Напиши отдельно SQL скрипт который заполнит каждую таблицу минимум на 100 строк с разными данными, можно больше, если этого требуют связи, индексы и ограничения.
Но данные должны быть согласованы, чтобы при дальнейшем построении связей, ограничений и индексов, согласно схеме ниже, не было ошибок и конфликтов.
Не должно быть повторяющихся записей, чтобы можно было построить связи, ограничения и индексы согласно схеме.
В каждом столбце должно быть минимум несколько значений Null, если это возможно, и несколько заполненных значений, если это возможно.
Проверь внимательно, чтобы он точно работал для postgresql 14!

3. Напиши отдельно SQL скрипт, который создаст все необходимые связи, ограничения и индексы между таблицами, согласно схеме.
Если связь, ограничение или индекс требует уникальности записи, сделай перед этим скрипт, который удалит все подобные дубликаты.
Если связь по схеме была непонятна, тогда не делай её в SQL запросе, а просто в конце ответа напиши об этом!
Проверь внимательно, чтобы он точно работал для postgresql 14!

4. Напиши отдельно SQL скрипт для удаления всех индексов, связей и ограничений для текущих таблиц из базы данных.
Проверь внимательно, чтобы он точно работал для postgresql 14!

5. Напиши отдельно SQL скрипт для очистки всех таблиц из текущей базы.
Именно очистки, а не удаления самих таблиц!
Учти, что могут быть связи, индексы и иные ограничения!
Проверь внимательно, чтобы он точно работал для postgresql 14!

6. Напиши отдельно SQL скрипт удаления всех таблиц из текущей базы.
Учти, что могут быть связи, индексы и иные ограничения!
Проверь внимательно, чтобы он точно работал для postgresql 14!

Мои дополнительные предпочтения:
- нет

Схема таблиц базы данных:`;
function setActiveButton(btn){
  document.querySelectorAll("button").forEach(b=>b.classList.remove("btn-active"));
  if(btn) btn.classList.add("btn-active");
}
let toastTimer=null;
function showToast(msg="Скопировано в буфер."){
  const el=document.getElementById("toast");
  el.textContent=msg;
  el.classList.remove("hide");
  el.classList.add("show");
  clearTimeout(toastTimer);
  toastTimer=setTimeout(()=>{
    el.classList.add("hide");
    el.classList.remove("show");
  }, 1750);
}
const getAttr=(el,n,d="")=>el.getAttribute(n)??d;
function plain(v){
  if(v==null) return "";
  const dec=String(v).replace(/&(lt|gt|amp|quot|#39);/g,m=>({'<':'<','>':'>','&amp;':'&','&quot;':'"','&#39;':"'" }[m]));
  const noTags=dec.replace(/<[^>]*>/g,"");
  return noTags.replace(/\s+/g," ").trim();
}
function isFlagsText(t){
  t = plain(t);
  return !!t && /^(?:PK|FK|UN\d+)(?:\s*,\s*(?:PK|FK|UN\d+))*$/i.test(t);
}
function parseFlagsList(arr){
  const r={pk:false,fk:false,uniqueGroups:[]};
  for(const item of arr){
    const s=plain(item); if(!s) continue;
    for(const tok of s.split(",").map(x=>x.trim()).filter(Boolean)){
      const u=tok.toUpperCase();
      if(u==="PK") r.pk=true; else if(u==="FK") r.fk=true; else if(/^UN\d+$/.test(u)) r.uniqueGroups.push(u);
    }
  }
  return r;
}
function byY(a,b){
  const ya=Number(a.getElementsByTagName("mxGeometry")[0]?.getAttribute("y")||"0");
  const yb=Number(b.getElementsByTagName("mxGeometry")[0]?.getAttribute("y")||"0");
  return ya-yb;
}
const isSnake=(s)=>/^[a-z0-9]+(?:_[a-z0-9]+)*$/.test(s);
const toSnake=(s)=>s.replace(/([a-z0-9])([A-Z])/g,"$1_$2").replace(/([A-Z]+)([A-Z][a-z0-9])/g,"$1_$2").toLowerCase();
const isLowercase=(s)=> s === s.toLowerCase();
const isPluralEn=(s)=> /s$/.test(s);
function columnMap(tbl){
  const m=new Map();
  for(const c of tbl.columns) m.set(c.name,c);
  return m;
}
function validateModel(model){
  const issues=new Map();
  const add=(t,msg)=>{ if(!issues.has(t)) issues.set(t,[]); issues.get(t).push(msg); };
  for(const [tname, tbl] of Object.entries(model.tables)){
    const cols = tbl.columns.map(c=>c.name);
    const cMap = columnMap(tbl);
    if(!isSnake(tname)) add(tname, `Имя таблицы должно быть в snake_case: ${tname}`);
    const nonSnakeCols = tbl.columns.filter(c=>!isSnake(c.name));
    if(nonSnakeCols.length){
      add(tname, `Поля не в snake_case: ${nonSnakeCols.map(c=>c.name).join(", ")}`);
    }
    if(!isLowercase(tname) || !isPluralEn(tname)){
      add(tname, `Имя таблицы — во множественном числе и в нижнем регистре (например: offices)`);
    }
    if(cols.includes("id") && !tbl.primaryKey.includes("id")){
      add(tname, `Столбец 'id' должен быть первичным ключом (PK)`);
    }
    if(cols.includes("uuid") && !tbl.primaryKey.includes("uuid")){
      add(tname, `Столбец 'uuid' должен быть первичным ключом (PK)`);
    }
    for(const fk of (tbl.foreignKeys||[])){
      const expected = `${fk.refTable}_${fk.refColumn}`;
      if(fk.column !== expected){
        add(tname, `Неверное имя FK '${fk.column}'. Ожидается: ${expected}`);
      }
      const col = cMap.get(fk.column);
      if(col && !col.fk){
        add(tname, `У столбца '${fk.column}' отсутствует флаг FK`);
      }
      if(fk.refColumn === "uuid"){
        if(!/_uuid$/.test(fk.column)) add(tname, `FK '${fk.column}' должен оканчиваться на '_uuid' (ссылка на PK 'uuid')`);
      }else{
        if(!/_id$/.test(fk.column)) add(tname, `FK '${fk.column}' должен оканчиваться на '_id' (ссылка на не-uuid PK)`);
      }
    }
    const okAuditAt = new Set(["created_at","changed_at","deleted_at"]);
    const okAuditBy = new Set(["created_by","changed_by","deleted_by"]);
    const auditBad = cols.filter(n => /^(created|changed|deleted)/.test(n) && !(okAuditAt.has(n) || okAuditBy.has(n)));
    if(auditBad.length){
      add(tname, `Некорректные имена аудита: ${auditBad.join(", ")} (ожидается *_at или *_by)`);
    }
    const boolBad = cols.filter(n => /^(is|should)[_a-z0-9]*/i.test(n) && !/^has[_a-z0-9]*/i.test(n));
    if(boolBad.length){
      add(tname, `Нежелательные имена для boolean: ${boolBad.join(", ")} (избегайте is*/should*, 'has*' допустимо)`);
    }
  }
  return issues;
}
function getColorName(fillColor) {
  if (!fillColor) return "без цвета";
  
  // Нормализуем цвет (убираем # если есть)
  const normalizedColor = fillColor.replace(/^#/, '').toLowerCase();
  
  // Определяем цвет по известным значениям
  switch(normalizedColor) {
    case "fff2cc": return "жёлтый";
    case "dae8fc": return "синий";
    case "d5e8d4": return "зелёный";
    default: return "неизвестный цвет";
  }
}
function parseDrawio(xml){
  const doc=new DOMParser().parseFromString(xml,"text/xml");
  const mx=doc.getElementsByTagName("mxGraphModel")[0];
  if(!mx) throw new Error("mxGraphModel не найден. Экспортируйте несжатый XML.");
  const cells=Array.from(doc.getElementsByTagName("mxCell"));
  const children=new Map();
  for(const c of cells){const p=getAttr(c,"parent"); if(!children.has(p)) children.set(p,[]); children.get(p).push(c)}
  const tables=[];
  for(const c of cells){
    if(getAttr(c,"vertex")!=="1") continue;
    const style=getAttr(c,"style","");
    if(!/shape=table/.test(style)) continue;
    const name=plain(getAttr(c,"value",""));
    if(!name) continue;
    tables.push({id:getAttr(c,"id"),name,style});
  }
  const model={tables:{},relationships:[]};
  const rowInfoByRowId=new Map();
  for(const t of tables){
    const kids=(children.get(t.id)||[]);
    let rows=kids.filter(r=>getAttr(r,"vertex")==="1" && /shape=tableRow/.test(getAttr(r,"style","")));
    if(!rows.length){ rows=kids.filter(r=>getAttr(r,"vertex")==="1" && /shape=partialRectangle/.test(getAttr(r,"style",""))); }
    rows.sort(byY);
    const columns=[], pkCols=[], uniqueGroups=new Map();
    for(const row of rows){
      const rowId=getAttr(row,"id");
      const rKids=(children.get(rowId)||[]);
      const childParts=[];
      for(const k of rKids){
        const val=plain(getAttr(k,"value",""));
        const gx=Number(k.getElementsByTagName("mxGeometry")[0]?.getAttribute("x")||"0");
        childParts.push({val,gx,isFlag:isFlagsText(val)});
      }
      const flagTexts = childParts.filter(p=>p.isFlag).map(p=>p.val);
      const fl = parseFlagsList(flagTexts);
      let nameCandidate = childParts.filter(p=>!p.isFlag && p.val).sort((a,b)=>a.gx-b.gx).pop()?.val || "";
      if(!nameCandidate){
        const rowVal=plain(getAttr(row,"value",""));
        if(rowVal && !isFlagsText(rowVal)) nameCandidate=rowVal;
      }
      if(!nameCandidate){
        nameCandidate = childParts.find(p=>!p.isFlag && p.val)?.val || "";
      }
      if(!nameCandidate) continue;
      let col={name:nameCandidate, pk:!!fl.pk, fk:!!fl.fk, unique:false};
      if (col.pk) {
        if (col.name === "id") col.dataType = "serial";
        else if (col.name === "uuid") col.dataType = "uuid";
      }
      columns.push(col);
      if(fl.pk) pkCols.push(nameCandidate);
      for(const g of fl.uniqueGroups){
        if(!uniqueGroups.has(g)) uniqueGroups.set(g,[]);
        uniqueGroups.get(g).push(nameCandidate);
      }
      rowInfoByRowId.set(rowId,{table:t.name,column:nameCandidate,flags:fl});
    }
    const indexes=[];
    for(const [g,cols] of uniqueGroups){
      if(cols.length===1){
        const c=columns.find(x=>x.name===cols[0]); if(c) c.unique=true;
        indexes.push({name:`unique_${t.name}_${cols[0]}`,columns:[...cols],unique:true,synth:true});
      } else if(cols.length>1){
        indexes.push({name:g,columns:[...cols],unique:true,synth:false});
      }
    }
    // Извлекаем цвет из стиля
    const fillColorMatch = t.style.match(/fillColor=([^;]+)/);
    const fillColor = fillColorMatch ? fillColorMatch[1] : null;
    
    model.tables[t.name]={columns,primaryKey:pkCols,unique:columns.filter(c=>c.unique).map(c=>c.name),checks:[],indexes,foreignKeys:[],fillColor};
  }
  const arrowToCard = (tok)=>{
    const v = (tok||"").toLowerCase();
    if(/ermany|crow|crowfoot|many/.test(v)) return "N";
    if(/erone|one/.test(v)) return "1";
    if(/zerotomany|zero_to_many|0\.\.*n|0..n/.test(v)) return "N";
    if(/zerotoone|zero_to_one|0\.\.*1|0..1/.test(v)) return "1";
    if(/mand/.test(v)) return "N";
    return "?";
  };
  for(const e of cells.filter(x=>getAttr(x,"edge")==="1"))
  {
    const edgeId=getAttr(e,"id");
    const srcId=getAttr(e,"source"), trgId=getAttr(e,"target");
    if(!srcId||!trgId) continue;
    const s=rowInfoByRowId.get(srcId), t=rowInfoByRowId.get(trgId);
    if(!s||!t) continue;
    const style = (getAttr(e,"style","")||"").toLowerCase();
    const getTok = side => ((style.match(new RegExp(side+"Arrow=([^;]+)"))||[])[1]||"");
    let srcCard = arrowToCard(getTok("start"));
    let trgCard = arrowToCard(getTok("end"));
    const lbs=(children.get(edgeId)||[]).filter(lb=>/edgeLabel/.test(getAttr(lb,"style","")));
    const setSide = (isSource, val) => {
      const v = (val==="n"||val==="N")?"N":(val==="1")?"1":"?";
      if(isSource) srcCard=v; else trgCard=v;
    };
    for(const lb of lbs){
      const raw=plain(getAttr(lb,"value","")).toLowerCase();
      if(!raw) continue;
      const g = lb.getElementsByTagName("mxGeometry")[0];
      const gx = parseFloat(g?.getAttribute("x")||"0");
      if(raw.includes(":")){
        const [a,b]=raw.split(":");
        if(gx<0){ setSide(true,a); setSide(false,b); }
        else    { setSide(false,a); setSide(true,b); }
      } else if(raw==="1"||raw==="n"){
        if(gx<0) setSide(true,raw); else setSide(false,raw);
      }
    }
    let fk=s, pk=t;
    if(s.flags.fk && !t.flags.fk){ fk=s; pk=t; }
    else if(t.flags.fk && !s.flags.fk){ fk=t; pk=s; }
    else{
      const sFk=/_id$/.test(s.column), tFk=/_id$/.test(t.column);
      if(sFk && !tFk){ fk=s; pk=t; }
      else if(tFk && !sFk){ fk=t; pk=s; }
      else {
        const cardOnly=`${srcCard}:${trgCard}`;
        model.relationships.push({from:`${s.table}.${s.column}`,to:`${t.table}.${t.column}`,type:cardOnly,via:"edge(?)"});
        continue;
      }
    }
    if(srcCard==="?" || trgCard==="?"){
      const fkIsSource = (fk===s);
      if(fkIsSource){ if(srcCard==="?") srcCard="N"; if(trgCard==="?") trgCard="1"; }
      else          { if(srcCard==="?") srcCard="1"; if(trgCard==="?") trgCard="N"; }
    }
    const card = `${srcCard}:${trgCard}`;
    const tbl=model.tables[fk.table];
    if(tbl){
      const exists=tbl.foreignKeys?.some(x=>x.column===fk.column&&x.refTable===pk.table&&x.refColumn===pk.column);
      if(!exists){
        (tbl.foreignKeys||(tbl.foreignKeys=[])).push({column:fk.column,refTable:pk.table,refColumn:pk.column});
      }
    }
    model.relationships.push({from:`${fk.table}.${fk.column}`,to:`${pk.table}.${pk.column}`,type:card,via:"edge(FK)"});
  }
  // ДОРАБОТКА: выставляем типы данных FK в соответствии с PK
  for (const [tname, tbl] of Object.entries(model.tables)) {
    if (!tbl.foreignKeys) continue;
    for (const fk of tbl.foreignKeys) {
      const refTable = model.tables[fk.refTable];
      if (!refTable) continue;
      const refCol = refTable.columns.find(c => c.name === fk.refColumn);
      if (refCol) {
        const fkCol = tbl.columns.find(c => c.name === fk.column);
        if (fkCol && !fkCol.dataType) {
          fkCol.dataType = refCol.dataType || (refCol.name === "id" ? "serial" : refCol.name === "uuid" ? "uuid" : "");
        }
      }
    }
  }
  return model;
}
function modelToText(model){
  const out=[];
  const useColors = colorCheckbox.checked;
  for(const t of Object.keys(model.tables).sort()){
    const tbl=model.tables[t];
    let tableLine = `table:${t}`;
    if (useColors) {
      const colorName = getColorName(tbl.fillColor);
      tableLine += ` (${colorName})`;
    }
    out.push(tableLine);
    for(const c of tbl.columns){
      const tags=[]; if(c.pk) tags.push("PK"); if(c.unique) tags.push("unique");
      out.push(`- ${c.name}${tags.length?` [${tags.join(",")}]`:""}`)
    }
    if(tbl.primaryKey.length) out.push(`PK:(${tbl.primaryKey.join(",")})`);
    if(tbl.indexes.length) for(const ix of tbl.indexes) out.push(`index:${ix.name}(${ix.columns.join(",")}) unique`);
    if(tbl.foreignKeys?.length) for(const fk of tbl.foreignKeys) out.push(`FK:${fk.column}->${fk.refTable}.${fk.refColumn}`);
    out.push("");
  }
  if(model.relationships.length){
    out.push("связи:");
    for(const r of model.relationships) out.push(`${r.from}->${r.to} [${r.type}]`)
  }
  return out.join("\n").trim();
}
const TABLE_HEADERS=["Поле","Тип данных","Обязательность","Описание","Варианты значений","Ограничения"];
function buildConstraintsPerColumn(tableName, tblModel){
  const map=new Map(); const ensure=c=>{if(!map.has(c)) map.set(c,[])};
  for(const c of (tblModel.primaryKey||[])){ ensure(c); map.get(c).push("PK") }
  for(const fk of (tblModel.foreignKeys||[])){ ensure(fk.column); map.get(fk.column).push("FK") }
  for(const ix of (tblModel.indexes||[])){
    if(!ix.unique) continue;
    if(ix.columns.length===1){
      const c=ix.columns[0]; ensure(c);
      const idxName = ix.name || `unique_${tableName}_${c}`;
      map.get(c).push(`UN (индекс ${idxName})`);
    } else {
      const idxName = ix.name || `unique_${tableName}_${ix.columns.join("_")}`;
      for(const c of ix.columns){
        ensure(c);
        const others = ix.columns.filter(x=>x!==c).join(", ");
        map.get(c).push(`UN: связка с ${others} (индекс ${idxName})`);
      }
    }
  }
  return map;
}
function typeForColumn(col, primaryKey){
  if(primaryKey.length===1){
    const pk = primaryKey[0];
    if(col.name===pk && col.name==="id") return "serial";
    if(col.name===pk && col.name==="uuid") return "uuid";
  }
  return "";
}
function buildHTMLTable(tableName, tbl){
  const table=document.createElement("table");
  const thead=document.createElement("thead");
  const trh=document.createElement("tr");
  for(const h of TABLE_HEADERS){ const th=document.createElement("th"); th.textContent=h; trh.appendChild(th); }
  thead.appendChild(trh); table.appendChild(thead);
  const tbody=document.createElement("tbody");
  const constrMap=buildConstraintsPerColumn(tableName, tbl);
  const camelPairs=[];
  for(const col of tbl.columns){
    const tr=document.createElement("tr");
    const notNull = col.pk ? "Not null" : "";
    const constraints = (constrMap.get(col.name)||[]).join("; ");
    if(!isSnake(col.name) && /[A-Z]/.test(col.name)){ camelPairs.push({orig:col.name, snake:toSnake(col.name)}); }
    const typ = col.dataType || typeForColumn(col, tbl.primaryKey) || "";
    const cells=[ col.name, typ, notNull, "", "", constraints ];
    for(const v of cells){ const td=document.createElement("td"); td.textContent=v; tr.appendChild(td); }
    tbody.appendChild(tr);
  }
  table.appendChild(tbody);
  let html = table.outerHTML;
  if(camelPairs.length){
    const noteHtml = `<div class="camel-note">
      <div class="note-title">Поля camelCase должны быть snake_case!</div>
      ${camelPairs.map((p,i)=>`${i+1}. ${p.orig} → ${p.snake}`).join("<br>")}
    </div>`;
    html = `<div>${html}${noteHtml}</div>`;
  }
  return {tableEl:table, htmlForCopy:html, camelPairs};
}
function renderConfluenceTables(model){
  const warnings = validateModel(model);
  const container=document.getElementById("tablesContainer");
  container.innerHTML="";
  const tnames=Object.keys(model.tables).sort();
  for(const t of tnames){
    const tbl=model.tables[t];
    const card=document.createElement("div"); card.className="table-card";
    const title=document.createElement("div"); title.className="table-title"; title.textContent=`Таблица: ${t}`;
    card.appendChild(title);
    const copyBtn=document.createElement("button");
    copyBtn.className="copy-btn-inline"; copyBtn.textContent="Копировать";
    copyBtn.addEventListener("click",(e)=>copyTableAsHTML(t, tbl, e.currentTarget));
    card.appendChild(copyBtn);
    const {tableEl, camelPairs}=buildHTMLTable(t, tbl);
    card.appendChild(tableEl);
    const ws = warnings.get(t);
    if(ws && ws.length){
      const warn = document.createElement("div");
      warn.className="warn-note";
      warn.innerHTML = `<div class="warn-title">Предупреждения по правилам</div><ul style="margin:0;padding-left:18px">${ws.map(x=>`<li>${x}</li>`).join("")}</ul>`;
      card.appendChild(warn);
    }
    if(camelPairs.length){
      const note=document.createElement("div");
      note.className="camel-note";
      const list = camelPairs.map((p,i)=>`${i+1}. ${p.orig} → ${p.snake}`).join("<br>");
      note.innerHTML=`<div class="note-title">Поля camelCase должны быть snake_case!</div>${list}`;
      card.appendChild(note);
    }
    container.appendChild(card);
  }
}
async function copyHTML(html, plainFallback="", btn){
  setActiveButton(btn);
  if(navigator.clipboard && window.ClipboardItem){
    const data = { "text/html": new Blob([html], {type:"text/html"}), "text/plain": new Blob([plainFallback||html.replace(/<[^>]+>/g,"")], {type:"text/plain"}) };
    try{ await navigator.clipboard.write([new ClipboardItem(data)]); showToast(); return }catch(_){}
  }
  const ta=document.createElement("textarea"); ta.value=plainFallback||html; document.body.appendChild(ta); ta.select();
  try{document.execCommand("copy")}finally{document.body.removeChild(ta)}
  showToast();
}
function copyFrom(id, btn){
  const el=document.getElementById(id);
  copyHTML(el.innerHTML, el.textContent, btn);
}
function copyTableAsHTML(tableName, tbl, btn){
  const {htmlForCopy} = buildHTMLTable(tableName, tbl);
  copyHTML(htmlForCopy, "", btn);
}
function copyPromptPlusOutput(btn){
  const out=document.getElementById("output").textContent || "";
  const payload = (prompt_ai_sql||"").trim() + "\n\n" + out.trim();
  setActiveButton(btn);
  if(navigator.clipboard && window.ClipboardItem){
    const data={"text/plain": new Blob([payload], {type:"text/plain"})};
    navigator.clipboard.write([new ClipboardItem(data)]).then(()=>showToast()).catch(()=>{
      fallbackCopy(payload); showToast();
    });
  }else{ fallbackCopy(payload); showToast(); }
}
function fallbackCopy(text){
  const ta=document.createElement("textarea");
  ta.value=text; document.body.appendChild(ta); ta.select();
  try{document.execCommand("copy")}finally{document.body.removeChild(ta)}
}
async function analyzeDB(btn) {
  setActiveButton(btn);
  try {
    // Загружаем содержимое файла promt_analyze.txt
    const response = await fetch('/promt_analyze.txt');
    if (!response.ok) {
      throw new Error(`Ошибка загрузки файла: ${response.status} ${response.statusText}`);
    }
    const fileContent = await response.text();
    
    // Получаем текст из поля вывода
    const outputText = document.getElementById("output").textContent || "";
    
    // Формируем полный текст для копирования
    const fullText = `${fileContent}\n\nСхема в текстовом варианте:\n${outputText}`;
    
    // Копируем в буфер обмена
    if(navigator.clipboard && window.ClipboardItem){
      const data={"text/plain": new Blob([fullText], {type:"text/plain"})};
      await navigator.clipboard.write([new ClipboardItem(data)]);
      showToast("Текст для анализа скопирован в буфер");
    } else {
      fallbackCopy(fullText);
      showToast("Текст для анализа скопирован в буфер");
    }
  } catch (error) {
    console.error('Ошибка при загрузке файла:', error);
    showToast("Ошибка загрузки файла promt_analyze.txt");
  }
}
function run(){
  const xml=document.getElementById("xmlInput").value;
  const out=document.getElementById("output");
  const tablesWrap=document.getElementById("tablesContainer");
  try{
    const model=parseDrawio(xml);
    const text=modelToText(model);
    out.classList.remove("error"); out.textContent=text;
    renderConfluenceTables(model);
  }catch(e){
    out.classList.add("error");
    out.textContent="Ошибка: "+(e?.message||e);
    tablesWrap.innerHTML="";
  }
}
</script>
</body>
</html>